diff --git a/postgresql-17.4/src/backend/access/nbtree/nbtsearch.c b/postgresql-17.4/src/backend/access/nbtree/nbtsearch.c
index e0bbb97..b9a3afb 100644
--- a/postgresql-17.4/src/backend/access/nbtree/nbtsearch.c
+++ b/postgresql-17.4/src/backend/access/nbtree/nbtsearch.c
@@ -333,30 +333,71 @@ _bt_moveright(Relation rel,
  * the given page.  _bt_binsrch() has no lock or refcount side effects
  * on the buffer.
  */
+
 static OffsetNumber
 _bt_binsrch(Relation rel,
-			BTScanInsert key,
-			Buffer buf)
+            BTScanInsert key,
+            Buffer buf)
 {
-	Page		page;
-	BTPageOpaque opaque;
-	OffsetNumber low,
-				high;
-	int32		result,
-				cmpval;
-
-	page = BufferGetPage(buf);
-	opaque = BTPageGetOpaque(page);
-
-	/* Requesting nextkey semantics while using scantid seems nonsensical */
-	Assert(!key->nextkey || key->scantid == NULL);
-	/* scantid-set callers must use _bt_binsrch_insert() on leaf pages */
-	Assert(!P_ISLEAF(opaque) || key->scantid == NULL);
-
-	low = P_FIRSTDATAKEY(opaque);
-	high = PageGetMaxOffsetNumber(page);
-
-	/*
+    Page        page;
+    BTPageOpaque opaque;
+    OffsetNumber low,
+                high;
+    int32       result,
+                cmpval;
+
+    page = BufferGetPage(buf);
+    opaque = BTPageGetOpaque(page);
+
+    low = P_FIRSTDATAKEY(opaque);
+    high = PageGetMaxOffsetNumber(page);
+
+    int nitems = (int)(high - low + 1);
+
+    /* Linear scan shortcut for tiny leaf pages */
+    if (btree_binsrch_linear &&
+        P_ISLEAF(opaque) &&
+        nitems >= 2 &&
+        nitems <= btree_binsrch_linear_threshold)
+    {
+        elog(DEBUG1, "Linear search for %d elements", nitems);
+		OffsetNumber search_low = low;
+		OffsetNumber search_high = high;
+        // OffsetNumber off;
+		// int32 cmpval;
+		search_high++;
+		cmpval = key->nextkey ? 0 : 1;
+
+		while (search_high > search_low)
+             {
+                 int32 result = _bt_compare(rel, key, page, search_low);
+                 
+                 if (result >= cmpval)
+                 {
+                     /* This matches: low = mid + 1 in binary search */
+                     search_low++;
+                 }
+                 else
+                 {
+                     /* This matches: high = mid in binary search */
+                     /* In linear search, we found our boundary */
+                     break;
+                 }
+             }
+             
+             /* At this point search_high == search_low (same as binary search end) */
+             
+             /* Apply identical leaf page logic as binary search */
+             if (key->backward)
+                 return OffsetNumberPrev(search_low);
+                 
+             return search_low;
+    }
+
+
+     
+
+    /*
 	 * If there are no keys on the page, return the first available slot. Note
 	 * this covers two cases: the page is really empty (no keys), or it
 	 * contains only a high key.  The latter case is possible after vacuuming.
@@ -1578,6 +1619,25 @@ _bt_readpage(IndexScanDesc scan, ScanDirection dir, OffsetNumber offnum,
 
 	page = BufferGetPage(so->currPos.buf);
 	opaque = BTPageGetOpaque(page);
+	if (btree_leaf_prefetch)
+		{
+			bool is_leaf = (opaque->btpo_flags & BTP_LEAF) != 0;
+			if (is_leaf)
+			{
+			
+				BlockNumber nextblk = InvalidBlockNumber;
+				if (ScanDirectionIsForward(dir))
+					nextblk = opaque->btpo_next;
+				else
+					nextblk = opaque->btpo_prev;
+			
+			if (BlockNumberIsValid(nextblk))
+				{
+					PrefetchBuffer(scan->indexRelation, MAIN_FORKNUM, nextblk);
+					elog(DEBUG1, "Prefetch for the btree is scheduled for %u", nextblk);
+				}
+			}
+		}
 
 	/* allow next page be processed by parallel worker */
 	if (scan->parallel_scan)
@@ -1936,7 +1996,7 @@ _bt_readpage(IndexScanDesc scan, ScanDirection dir, OffsetNumber offnum,
 		so->currPos.lastItem = MaxTIDsPerBTreePage - 1;
 		so->currPos.itemIndex = MaxTIDsPerBTreePage - 1;
 	}
-
+	
 	return (so->currPos.firstItem <= so->currPos.lastItem);
 }
 
diff --git a/postgresql-17.4/src/backend/access/nbtree/nbtutils.c b/postgresql-17.4/src/backend/access/nbtree/nbtutils.c
index 878f4b2..f70c1e9 100644
--- a/postgresql-17.4/src/backend/access/nbtree/nbtutils.c
+++ b/postgresql-17.4/src/backend/access/nbtree/nbtutils.c
@@ -103,7 +103,9 @@ static void _bt_checkkeys_look_ahead(IndexScanDesc scan, BTReadPageState *pstate
 static int	_bt_keep_natts(Relation rel, IndexTuple lastleft,
 						   IndexTuple firstright, BTScanInsert itup_key);
 
-
+bool btree_leaf_prefetch = false;
+bool btree_binsrch_linear = false;
+int  btree_binsrch_linear_threshold = 4;
 /*
  * _bt_mkscankey
  *		Build an insertion scan key that contains comparison data from itup
diff --git a/postgresql-17.4/src/backend/utils/misc/guc_tables.c b/postgresql-17.4/src/backend/utils/misc/guc_tables.c
index c42fccf..a4dc3b8 100644
--- a/postgresql-17.4/src/backend/utils/misc/guc_tables.c
+++ b/postgresql-17.4/src/backend/utils/misc/guc_tables.c
@@ -88,6 +88,8 @@
 #include "utils/plancache.h"
 #include "utils/ps_status.h"
 #include "utils/xml.h"
+#include "access/nbtree.h"
+
 
 /* This value is normally passed in from the Makefile */
 #ifndef PG_KRB_SRVTAB
@@ -770,6 +772,24 @@ StaticAssertDecl(lengthof(config_type_names) == (PGC_ENUM + 1),
 
 struct config_bool ConfigureNamesBool[] =
 {
+	{
+		{"btree_leaf_prefetch", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables btree leaf prefetching optimization."),
+			NULL
+		},
+		&btree_leaf_prefetch,
+		false,
+		NULL, NULL, NULL
+	},
+	{
+		{"btree_binsrch_linear", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables linear search for small btree arrays."),
+			NULL
+		},
+		&btree_binsrch_linear,
+		false,
+		NULL, NULL, NULL
+	},
 	{
 		{"enable_seqscan", PGC_USERSET, QUERY_TUNING_METHOD,
 			gettext_noop("Enables the planner's use of sequential-scan plans."),
@@ -2035,6 +2055,17 @@ struct config_bool ConfigureNamesBool[] =
 
 struct config_int ConfigureNamesInt[] =
 {
+	{
+
+		{"btree_binsrch_linear_threshold", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Sets the threshold for btree linear search."),
+			NULL
+		},
+		&btree_binsrch_linear_threshold,
+		4, 1, 32,
+		NULL, NULL, NULL
+	},
+	
 	{
 		{"archive_timeout", PGC_SIGHUP, WAL_ARCHIVING,
 			gettext_noop("Sets the amount of time to wait before forcing a "
diff --git a/postgresql-17.4/src/include/access/nbtree.h b/postgresql-17.4/src/include/access/nbtree.h
index 7493043..39fd49b 100644
--- a/postgresql-17.4/src/include/access/nbtree.h
+++ b/postgresql-17.4/src/include/access/nbtree.h
@@ -1159,6 +1159,10 @@ typedef struct BTOptions
 #define PROGRESS_BTREE_PHASE_PERFORMSORT_2				4
 #define PROGRESS_BTREE_PHASE_LEAF_LOAD					5
 
+extern bool btree_leaf_prefetch;
+extern bool btree_binsrch_linear;
+extern int  btree_binsrch_linear_threshold;
+
 /*
  * external entry points for btree, in nbtree.c
  */
